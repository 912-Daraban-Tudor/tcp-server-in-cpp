#include <cstdint>
#include <iostream>
#include <iomanip>
#include <vector>
#include <string>
#include <cassert>

uint32_t next_key(uint32_t key) {
    // Important: do the multiply/add using uint32_t (wrap modulo 2^32),
    // then reduce modulo 0x7FFFFFFF as in the PDF example.
    uint32_t tmp = key * 1103515245u + 12345u; // wraps in uint32_t automatically
    return tmp % 0x7FFFFFFFu;
}

uint8_t checksum_uint8(const std::string &s) {
    uint8_t sum = 0;
    for (unsigned char c : s) sum = uint8_t(sum + c); // wrap mod 256
    return sum;
}

int main() {
    // Example values from the PDF
    const std::string username = "testuser";
    const std::string password = "testpass";
    const uint8_t message_sequence = 87; // 0x57

    // 1) compute 8-bit checksums (sum complement as uint8_t)
    uint8_t user_sum = checksum_uint8(username);
    uint8_t pass_sum = checksum_uint8(password);

    std::cout << "username_sum = 0x" << std::hex << std::setw(2) << std::setfill('0')
              << int(user_sum) << std::dec << " (" << int(user_sum) << ")\n";
    std::cout << "password_sum = 0x" << std::hex << std::setw(2) << std::setfill('0')
              << int(pass_sum) << std::dec << " (" << int(pass_sum) << ")\n";

    // 2) initial key as specified: (seq << 16) | (user_sum << 8) | pass_sum
    uint32_t initial_key = (uint32_t(message_sequence) << 16) |
                           (uint32_t(user_sum) << 8) |
                           uint32_t(pass_sum);

    std::cout << "initial_key = 0x" << std::hex << initial_key << std::dec << "\n\n";

    // 3) generate cipher bytes (we'll generate 80 bytes to match the PDF chunk)
    const size_t N = 80;
    std::vector<uint8_t> cipher(N);
    uint32_t k = next_key(initial_key); // key0
    cipher[0] = uint8_t(k % 256);
    for (size_t i = 1; i < N; ++i) {
        k = next_key(k);
        cipher[i] = uint8_t(k % 256);
    }

    // Expected bytes (taken from the PDF example block).
    const std::vector<uint8_t> expected = {
            0xE5,0xBA,0x6B,0xC9,0xCE,0xEF,0xFC,0x86,0x48,0xE1,0x06,0xC8,0x62,0xF3,0xB1,0x96,
            0x18,0x72,0xC4,0xAD,0xE2,0x74,0x9D,0x13,0x51,0xB7,0x24,0x8E,0xB0,0x2A,0x1B,0xB9,
            0xFE,0x60,0x19,0xDF,0x2D,0x62,0xF4,0x1E,0xFF,0xCC,0x16,0x98,0xF2,0x44,0x2E,0xCF,
            0x5D,0xD2,0xA4,0x0E,0x30,0xA9,0x2F,0x3D,0x32,0x83,0x01,0xA6,0xE7,0x95,0xAB,0x09,
            0x0E,0x30,0xA9,0x2F,0x3D,0x32,0x83,0x00,0x3A,0xEC,0xB6,0xB8,0x91,0xF7,0x65,0x3A
    };

    // Print produced bytes (hex, grouped)
    std::cout << "Produced cipher bytes (first " << N << "):\n";
    for (size_t i = 0; i < N; ++i) {
        if (i % 16 == 0 && i != 0) std::cout << "\n";
        std::cout << std::hex << std::uppercase << std::setw(2) << std::setfill('0')
                  << int(cipher[i]) << " ";
    }
    std::cout << std::dec << "\n\n";

    // Verify against expected (first expected.size() bytes)
    if (expected.size() <= cipher.size()) {
        bool ok = true;
        for (size_t i = 0; i < expected.size(); ++i) {
            if (expected[i] != cipher[i]) {
                std::cerr << "Mismatch at index " << i << ": expected 0x"
                          << std::hex << int(expected[i]) << " got 0x" << int(cipher[i]) << std::dec << "\n";
                ok = false;
            }
        }
        if (ok) {
            std::cout << "SUCCESS: generated cipher bytes match the PDF example.\n";
            return 0;
        } else {
            std::cerr << "ERROR: generated bytes differ from example.\n";
            return 2;
        }
    } else {
        std::cerr << "ERROR: expected vector larger than generated output.\n";
        return 3;
    }
}
